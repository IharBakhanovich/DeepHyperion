# Data Analysis and Map Generation

## Goal

Uniform the analyses required to extract features form _samples_, generate rescaled maps (considering all the samples), 
and compute metrics of interests (misbehaviors, density, etc.)

## Pipeline

We assume to have access to the raw data about each experiment, which consists in a `timestamped` folder that
contains all the individuals (e.g., `npy` images) generated by the test generators and possibly the outcome of the
test (misclassified digit for MNIST).

The steps to generate the maps are:

1. Process the output of the tools and generate an `info_<ID>.json` file for each sample. This file contains the features, and various metadata about the sample (timestamp, sample-id, file location, tool name, run id, etc.)

   Go to the root of the project (`./DeepHyperion-BNG`) and run the following command (activating same virtual environment you used to run the tool) to process a dataset folder (folders will be recursively checked):

   ```
   py.exe report_generator/app.py generate-samples --force-attribute run 1 --force-attribute tool DeepHyperionBeamNG ./logs/run_XXX/simulations
   ```
> NOTE: the set of features to be computed is predefined for each tool.

    This command produces a `json` file named `into_<UUID>.json` for each of the inputs generated by the tool.
    
2. Process all the json files corresponding to the samples of all the runs for all the tools, to extract the maps `extrema` for each feature. Go to the root of the project (`./DeepHyperion-BeamNG`) and run the following command:

   ```
   py.exe report_generator/app.py extract-stats --parsable --feature <NAME> --feature <NAME> ./logs/run_XXX/simulations
   ```
   For example:

   ```
   python report_generator/app.py extract-stats --parsable --feature segment_count --feature mean_lateral_position ./logs/run_XXX/simulations
   ```
> NOTE: you should select features based on your config (see `run_xxx/config.json`).

  You should get an output similar to:
  
  ```
2020-12-22 22:41:02,764 INFO     Process Started
name=segment_count,min=1,max=5,missing=0
name=mean_lateral_position,min=166,max=178,missing=0
  ```
  
   This output reports for each of the selected features the name, min/max values, and the count of samples found for which that feature was not found (useful for debugging).

   Removing the `--parsable` option yields a structured (JSON-like) report:

   ```
2020-12-22 22:42:54,168 INFO     Process Started
{
    "total": 13,
    "features": {
        "segment_count": {
            "min": 1,
            "max": 5,
            "missing": 0
        },
        "mean_lateral_position": {
            "min": 166,
            "max": 178,
            "missing": 0
        }
    }
}
   ```

3. Build the map and visualize it. Maps can contain two or more features, but their visualization is limited to two features at the time. To generate a map and generate a report run the following command (add `--visualize` if you want to visualize the map):

   ```
   py.exe report_generator/app.py generate-map --feature <NAME> <MIN> <MAX> <NUM_CELL> --feature <NAME> <MIN> <MAX> <NUM_CELL> ./logs/run_XXX/simulations
   ```
   For example:

   ```
   py.exe report_generator/app.py generate-map --feature segment_count 1 5 4 --feature mean_lateral_position 166 178 25 ./logs/run_XXX/simulations
   ```
> NOTE: You should set the <MIN> <MAX> values for each feature based on previous command's output, otherwise, you might loose some individuals which are out of your defined bind.  
    
    > NOTE: You can add other features (assuming they are present in **all** the samples) by adding to the command entries like `--feature <NAME> <MIN> <MAX> <NUM_CELL>` (e.g., `--feature min_radius 0 30 25`).

   This command should produce a `stats` file under the `simulations` folder named like `DeepHyperionBeamNG-001-stats.json`. The content of this file should be similar to the following:
   
   ```
   2020-12-22 22:47:25,853 INFO     Process Started
{
    "Tool": "DeepHyperionBeamNG",
    "Run ID": "1",
    "Tags": [],
    "Total Samples": 13,
    "Valid Samples": 13,
    "Invalid Samples": 0,
    "Total Misbehaviors": 1,
    "MisbehaviorPerSample": 0.07692307692307693,
    "Features": {
        "segment_count": {
            "meta": {
                "name": "segment_count",
                "min-value": 1.0,
                "max-value": 5.0,
                "num-cells": 4
            },
            "stats": {
                "mean": 2.076923076923077,
                "stdev": 1.3821202589704016,
                "median": 2
            }
        },
        "mean_lateral_position": {
            "meta": {
                "name": "mean_lateral_position",
                "min-value": 166.0,
                "max-value": 178.0,
                "num-cells": 25
            },
            "stats": {
                "mean": 173.3846153846154,
                "stdev": 3.3301266627177397,
                "median": 174
            }
        }
    },
    "Reports": [
        {
            "Features": [
                "segment_count",
                "mean_lateral_position"
            ],
            "Sample Count": 13,
            "Outlier Count": 0,
            "Total Cells": 100,
            "Filled Cells": 6,
            "Mapped Misbehaviors": 1,
            "Misbehavior Relative Density": 0.16666666666666666,
            "Misbehavior Density": 0.01,
            "Filled Cells Density": 0.06,
            "Collisions": 2,
            "Misbehavior Collisions": 0,
            "Collision Ratio": 1.1666666666666667,
            "Misbehavior Collision Ratio": 0.0,
            "Coverage Sparseness": 20.2,
            "Misbehavior Sparseness": 0.0,
            "Avg Sample Distance": 13.0,
            "Avg Misbehavior Distance": 0
        }
    ]
}
```